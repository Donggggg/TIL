# V8 엔진

### V8 엔진이란?

- Google에서 만든 Javascript & 웹 어셈블리 엔진이다.
- 오픈 소스이고 C++로 작성되었다.
- Chrome과 node.js 그리고 최신에는 Edge에서도 사용되고 있다.
- V8 엔진은 인터프리터 방식처럼 한 줄씩.. 컴파일하지 않는다.
- 소스 코드 전체를 Byte Code로 만들고, 후에 런타임에 최적화 기법을 추가하며 최적화한다.
- 그렇기에 V8 엔진은 JIT(Just-In-Time) 컴파일러이다.

### 내부 쓰레드

1. 소스 코드를 컴파일하고 실행하는 메인쓰레드가 있다.
2. 코드를 최적화하는 쓰레드가 있다.
3. 프로파일링을 하는 프로파일러 쓰레드가 있다.
4. 그 외 가비지 컬렉션을 위한 몇 개의 쓰레드가 있다.

## 동작 방식

### 동작 순서

![V8 엔진 동작 순서](https://i.imgur.com/mV0lX7i.png)

1. Blink(HTML, CSS 엔진)에서 `<script>` 태그를 만나면 Javascript 컴파일링을 시작한다.
2. 소스 코드를 `파서(Parser)`로 보낸다.
3. 파서는 소스 코드를 분석한 후 `AST(Abstract Syntax Tree), 추상 구문 트리`로 변환한다.
4. AST는 `Ignition, 점화기`를 통해 `Byte Code(바이트 코드)`로 변환된다.
5. 컴파일된 바이트 코드를 실행하여 소스 코드가 실제로 동작하게 된다.

### Parser와 AST

- Parser는 Token을 가지고 Ignition이 사용할 AST를 만든다.
- AST는 소스코드를 트리 구조로 만든 자료구조이고, 컴파일러에서 주로 사용된다.
- V8은 모든 코드를 즉시 Parsing하지 않는다.
  - 실행하지 않을 코드를 컴파일하면 리소스가 낭비된다.
  - 컴파일 후 메모리에 적재하고 있어야 하기 때문에, 가비지가 회수하기 전까지 메모리가 낭비된다.
- 이를 해결하기 위해 `Pre-Parser`를 함께 진행한다.
- Token 중 참조하지 않는 Token을 Pre-Parser로 전달하여 실제 작업에 필요한 최소한을 파싱하고 Pre-Parser로 나중에 요청시 컴파일된다.

### Ignition(점화기)

- AST를 Byte Code로 컴파일 한다.

```
0xfde0821004e LdaConstant [0]
0xfde08210050 Star r1
0xfde08210052 Mov <closure>, r2
0xfde08210055 CallRuntime [DeclareGlobals], r1-r2
0xfde0821005a LdaGlobal [1], [0]
0xfde0821005d Star r1
0xfde0821005f LdaSmi [101]
0xfde08210061 Star r2
0xfde08210063 LdaSmi.Wide [201]
0xfde08210067 Star r3
0xfde08210069 CallUndefinedReceiver2 r1, r2, r3, [2]
0xfde0821006e Star r0
0xfde08210070 Return
```

- 위와 같이 레지스터와 관련된 형태로 표현된다.
- 바이트 코드는 기계어로 해석되기 바로 전단계이다.

### Turbofan

- Turbofan은 Profiler가 분석한 결과를 기반으로 컴파일된 바이트 코드를 최적화시킨다.
- 메모리 사용량 감소, 실행시간 단축, 코드 크기를 줄이고 속도 향상의 효과를 가진다.

```
1. Hot & Stable : 자주 호출되고 코드가 변하지 않는 경우
2. Small Function: 짧은 함수인 경우
```

- 위 두가지 경우에 최적화가 진행된다.

```
1. Graph Building: 바이트 코드 또는 AST를 Graph로 만든다.
2. Native Context Specialization & Inlining: Load/Store/Call IC를 기반으로 기본 컨텍스트에 특화된 Simple Graph를 생성한다.
3. Typed Opimization: Type에 따라 Simple Graph로 변환한다.
4. General Optimization: Graph를 기반으로 중복 제거 같은 최적화를 진행한다.
5. Code Generation: 죽은 코드를 제거하고, 레지스터에 할당한다.
```

- 위의 과정은 구글에서 제공한 Turbofan 내부 동작과정인데 굉장히 어렵다..;

## 메모리 관리

### 메모리 구조

- 자바스크립트는 싱글 스레드이기 때문에 컨텍스트 당 하나의 프로세스를 사용한다.
- 실행 중인 프로그램은 V8 프로세스에서 할당된 일정량의 메모리로 표현되고 이를 `Resident Set`이라고 한다.
  ![](https://i.imgur.com/RVoFOwK.png)

### 힙 메모리

- 객체나 동적 데이터를 저장한다.
- 메모리 영역 중 가장 큰 블록이면서 가비지 컬렉션이 발생하는 곳이다.
- 가비지 컬렉션은 힙 메모리 내부의 Young과 Old 영역에서 일어난다.

1. New 영역
   새로 만들어진 모든 객체를 저장하고 짧은 생명주기를 가진다.
   크기가 작고 2개의 세미 영역을 가진다.
   `스케벤져`라고 불리는 `마이너 GC`가 관리한다.

2. Old 영역
   마이너 GC가 두 번 발생할 동안 'New 영역'에서 살아남은 객체들이 이동하는 영역이다.
   메이저 GC가 관리한다.
   `Old 포인터 영역`은 살아남은 객체들을 관리하며 이 객체들은 다른 객체를 참조한다.
   `Old 데이터 영역`은 데이터만 가진 객체(문자열 등)들을 가진다.

3. 라지 오브젝트 영역
   다른 영역의 제한된 크기보다 큰 객체들이 살고 있는 영역이다.
   mmap 메모리 영역을 가진다.
   가비지 컬렉터로 이동하지 않는다.

4. 코드 영역
   실시간(JIT) 컴파일러가 컴파일한 코드들을 저장하는 곳이다.
   유일하게 실행 가능한 메모리가 있는 영역이다.

5. 셀, 프로퍼티, 맵 영역
   각각 Cells, PropertyCells, Maps를 포함한다.
   각 영역은 모두 같은 크기의 객체들을 포함하여, 어떤 종류의 객체를 참조하는지에 대한 제약이 있어서 수집을 단순하게 만든다.

### 스택

- V8 프로세스마다 하나의 스택을 가진다.
- 메서드, 함수 프레임, 원시 값, 객체 포인터를 포함한 정적 데이터가 저장된다.

### 메모리 관리 특징

- 전역 스코프는 스택에서 '전역 프레임'에 보관된다.
- 모든 함수 호출은 프레임 블록에서 스택 메모리에 추가된다.
- 반환 값과 인자를 포함한 모든 지역 변수들은 함수 프레임 블록 안에 저장된다.
- int와 string과 같은 모든 원시 타입 값은 스택에 바로 저장된다.
- 객체 타입은 힙에서 생성되고 스택 포인터를 사용해 힙에서 스택을 참조한다.
- 현재 함수에서 호출된 함수들은 스택의 최상단에 추가된다.
- 함수 프레임이 반환될 때 스택에서 제거된다.
- 주요 프로세스가 완료될 때 힙에 있는 객체들은 어떤 포인터도 가지고 있지 않고 혼자 남게 된다.
- 명시적으로 복사하지 않으면, 다른 객체 내의 모든 객체 참조들은 참조 포인터를 사용해 연결된다.

### 가비지 컬렉션

- 동적으로 할당된 힙 메모리를 관리하기 위한 기법
- 참조 없는 객체들의 메모리를 비워 공간을 만든다.

### 마이너 GC (Scavenger)

- New 영역을 작고 깨끗하게 유지시킨다.
- 다음 할당될 메모리 위치를 가리키는 할당 포인터가 마지막에 도달하면 마이너 GC가 발생한다.
- 이 과정을 스케벤저라고 하며 Cheney의 알고리즘을 사용해 구현되었다.
- 매우 자주 발생하고 병렬 헬퍼 스레드를 사용하여 굉장히 빠르다.
- 세미 영역은 To 영역과 From 영역으로 나뉜다.
- 보통 새로운 할당은 To 영역에서 이뤄진다.
- stop-the-world 프로세스이지만 굉장히 빠르고 효율적이기에 무시할 수 있다.

```
// 마이너 GC의 과정

1. To 영역의 할당 포인터가 To 영역의 마지막을 넘어간다.
2. 마이너 GC가 발생한다.
3. 객체들은 To 영역에서 From 영역으로 이동시킨다.
4. GC 루트 (스택 포인터)부터 From 영역까지 객체 그래프를 재귀적으로 순회하며 메모리를 사용한 객체들을 찾는다.
5. 메모리를 사용하는 객체들은 To 영역의 페이지로 이동된다.
6. 모든 객체를 순회했으면 To 영역은 압축되어 조각화를 줄인다.
7. From 영역에 남아 있는 객체는 가비지이므로 From 영역을 비운다.
8. 또 다시 To 영역에서 마니어 GC가 발생하고 위의 과정이 반복된다.
9. 이때도 살아남은 객체들은 Old 영역으로 옮긴다.
```

### 메이저 GC

- Old 영역을 작고 깨끗하게 유지시킨다.
- Old 영역의 메모리가 충분하지 않다고 판단될 때 발생한다.
- Old 영역의 크기는 동적으로 계산된 크기에 기반하며 마이너 GC 주기에서 채워진다.
- `Mark-Sweep-Compact` 알고리즘을 사용하여 처리된다.
- Tri-Color(흰색-회색-검은색)마킹 시스템을 사용한다.
- 따라서 메이저 GC는 세 단계의 프로세스를 거치며, 세 번째 단계는 조각화 휴리스틱(fragmentation heuristic)에 따라 실행된다.
- 마킹(marking)
  - 두 알고리즘의 공통적인 첫 번째 단계로, 가비지 컬렉터가 어떤 객체를 사용중인지 식별한다.
  - 사용중이거나 GC 루트(스택포인터)에 재귀적으로 도달할 수 있는 객체들은 활성 상태로 표시한다.
  - 힙 메모리를 방향 그래프로 간주해 DFS를 수행한다.
- 스위핑(Sweeping)
  - 가비지 컬렉터가 힙 메모리를 순회하며 활성 상태로 표시되지 않은 객체들의 메모리 주소를 기록한다.
  - 이 공간은 이제 사용 가능한 목록에서 사용 가능하다고 표시되며 다른 객체들을 저장하는 데 사용될 수 있다.
- 압축(Compacting)
  - 스위핑이 일어난 다음, 필요하다면 모든 활성 상태의 객체들이 함께 이동될 것이다.
  - 압축 단계는 조각화를 줄이고 새 객체들에 대한 메모리 할당 성능을 증가시킨다.
- 메이저 GC는 처리 중 앱 실행을 멈추므로 stop-the-world GC이다.

```
// stop-the-world를 피하기 위한 기술

1. 인크리멘탈 GC(Incremetal GC)
  GC는 여러 개의 인크리멘탈 단계로 수행된다.
2. 동시 마킹(Concurrent Marking)
  마킹은 자바스크립트 메인 스레드에 영향을 주지 않고 다중 헬프 스레드를 사용해 동시에 수행된다.
  write barrier는 헬퍼들이 동시에 마킹하는 동안 자바스크립트가 생성한 객체 간 참조를 추적하는 데 사용된다.
3. 동시 스위핑/압축 (Concurrent Sweeping/Compacting)
  스위핑과 압축은 자바스크립트 메인 스레드에 영향을 주지 않고 헬퍼 스레드에서 동시에 수행된다.
4. 레이지 스위핑 (Lazy Sweeping)
  메모리가 필요할 때까지 페이지의 가비지 삭제를 지연시킨다.
```
