## 챕터4 - 테스트 구축하기

리팩터링을 제대로 하기 위해서는 견고한 테스트 환경이 필요하다. 해당 챕터에서는 테스트에 대해 간단히 다뤄본다.

### 4-1. 자가 테스트 코드의 가치

프로그래머들이 실제로 코드를 작성하는 시간은 그리 많지 않다. 현재 상황 파악, 설계 고민, 디버깅 등에 대부분의 시간을 사용한다. 특히 디버깅은 모든 개발자가 골치를 앓고 있는 부분이기도 하다. 버그를 수정하는 것은 금새 끝나지만 그 버그를 찾는 과정이 굉장히 고단한 편이다.

저자는 과거에 테스트 코드의 가치를 모르고 작성하지 않았지만 한 컨퍼런스에 참여한 뒤 테스트 코드를 작성하기 시작했다. 첫 테스트는 완벽하게 자동화되지 않았기 때문에 콘솔을 직접 확인하는 단계에 있었다. 이 과정이 비효율적이라고 느낀 저자는 테스트 결과를 비교하여 성공/실패를 구분하여 출력하도록 변경했다. 이것이 저자가 말하는 자가 테스트 소프트웨어(모든 테스틀 완전히 자동화하고 그 결과까지 스스로 검사하게 만들자)이다.

자가 테스트 소프트웨어는 테스트를 컴파일만큼 쉽게 만들었다. 컴파일과 동시에 테스트도 진행할 수 있었고 생산성을 급상승시킬 수 있었다. 테스트가 실패하면 최근 변경된 부분만 보면 어디서 버그가 발생했는지 쉽게 찾아볼 수 있게 되었다. 만약 테스트가 없었다면.. 작업은 속행되고 엄청난 양의 코드 중에 버그를 찾아야 했을 것이다.

이 후 자가 테스트 코드를 작성하는 도구가 급격히 발전했다. JUnit을 시작으로 수 많은 언어의 테스트 프레임워크들이 탄생했다.

실제로 많은 공감을 했던 부분이 테스트가 실제로 프로그래밍 속도를 높여주는 경험을 직접 해보지 않고서는 자가 테스트의 진가를 납득하기 어렵다라고 말하는 부분이다. 테스트에는 정답이 있는 것이 아니기 때문에 배우기도 어렵고 실제 작성을 할 때도 여러 어려움(케이스 작성, 목 환경, 다양한 종류 등)이 있다. 이 진입 장벽을 넘어야 테스트를 작성하고 테스트의 효과를 체감할 수 있는데 이 과정까지 도달하기가 쉽지 않았다고 느꼈다.

테스트를 작성하기 가장 좋은 시기는 프로그래밍을 시작하기 전이다. 테스트를 작성하다 보면 인터페이스(설계)에 집중하게 된다. 게다가 코딩이 완료되는 시점도 정확하게 판단할 수 있다. 이 점도 내가 생각하는 테스트의 어려운 점 중 하나이다. 처음부터 완벽한 테스트 코드를 짜기가 쉽지는 않았다. 테스트 코드도 결국 개발 중에 추가했던 경험이 있었다.

### 4-2. 테스트할 샘플 코드

지역(Province)의 수요/가격 계획을 여러 생산자(Producer)의 비용/생산량에 따라 부족분/총수익을 계산하는 애플리케이션의 코드를 예시로 가져왔다.

### 4-3. 첫 번째 테스트

책에서는 Mocha를 사용하여 테스트를 작성한다. 먼저 생산 부족분을 제대로 계산하는지 테스트한다. 픽스처를 설정하고 검증한다.

테스트가 성공하는데 안주하지 않고 고의로 에러를 내보는 과정이 필요하다고 한다.. 개인적인 생각으로 매번 이럴 필요는 없을 것 같고 직감적으로 필요한 경우에 고의 에러를 발생시켜볼 필요가 있을 것 같다.

Mocha는 어서션 라이브러리도 추가로 사용해야 한다. 이 책에서는 Chai를 사용한다. 저자는 assert를 선호하지만 자바스크립트에서는 expect를 주로 사용한다고 한다.

- assert
    - `assert.equal(asia.shortfall, 5)`
    - 해석이 잘 안되고 함수로 읽힌다.
- expect / should
    - BDD에 어울리는 방식이라고 Chai 공식 문서에서 제안
    - BDD란 [Behavior Driven Development](https://www.popit.kr/bdd-behaviour-driven-development%EC%97%90-%EB%8C%80%ED%95%9C-%EA%B0%84%EB%9E%B5%ED%95%9C-%EC%A0%95%EB%A6%AC/)의 준말
    - 시나리오 기반 테스트로 함수 단위가 아닌 시나리오를 중심으로 테스트를 작성한다.
    - 기본적인 패턴으로 Given(값)-When(조건)-Then(결과) 구조가 있다.
    - 어떤 값이 어떠할 때 어떻게 되는가?로 해석될 수 있게 테스트를 작성해야 한다.
    - `expect(asia.shortfall).equal(5)`
    - 해석하자면 ‘아시아의 부족분이 5와 동일하길 기대한다.’이고 이는 결과로 해석할 수 있다.
    - 추가로 Chai 기반에서는 expect가 제공되는 API가 더 많기에 대부분 expect로 사용된다.


### 4-4. 테스트 추가하기

앞에서 작성한 테스트 외에 추가로 테스트를 작성해 본다. 여기서 저자가 강조하는 점은 다음과 같다. 테스트는 위험 요인을 중심으로 작성해야 한다! 테스트의 목적은 현재나 미래의 버그를 찾는데 있기 때문에 단순히 읽기/쓰기 용의 접근자는 테스트할 필요 없다.

특히 테스트를 양산해내면 중요하고 필요한 테스트를 놓치기 쉽다. 그렇기에 필요없는 테스트를 잘 구분해서 작성하지 않고 필요 없어진 테스트도 즉각 삭제할 줄 알아야 한다.

그러므로 다음으로 중요하다고 생각되는 순이익을 검증하는 테스트를 작성한다. 이 때 픽스처를 사용하는 코드가 중복된다. 이 처리를 전역으로 관리하는 것은 굉장히 위험하다. 일명 공유 픽스처는 변할 가능성이 있어 위험하다. 이는 안전한 테스트를 만드는 것을 방해하기 때문에 지양해야 한다. 대신 beforeEach 구문을 사용해 픽스처를 사전 설정하는 방식을 추천한다.

### 4-5. 픽스처 수정하기

보통의 테스트는 설정-수행-검증의 패턴으로 진행된다. setup-exercise-verify, given-when-then, arragne-act-assert 등으로 불리는데, 이는 다양한 방식으로 작성된다. 해체(teardown)나 청소(cleanup)로 불리는 네 번째 단계도 있는데 이는 픽스터를 제거하는데 주로 사용된다. 드물지만 해체가 명시적으로 수행되어야 할 때 필요하다.

### 4-6. 경계 조건 검사하기

이전까지는 꽃길,,만 고려한 조건을 검증했다. 범위를 벗어나는 경계 지점를 검증하는 테스트를 작성하는 것이 더 좋다. 저자는 producers가 비었을 때, 숫자형 변수가 0일 때, 음수일 때 등을 검증한다. 여기서 주목할 부분은 과연 수요가 음수가 되는 것이 요구사항에 부합하느냐.. 생각해보면 전혀 아니다. 이를 예외 처리하는 코드를 추가로 작성해야 한다. (이를 보면 테스트를 작성하며 더 좋은 코드를 작성할 수 있다는 주장이 타당하다.)

다음으로 문제가 생길 가능성이 있는 부분을 집중적으로 테스트하는 것을 제안한다. 이 프로그램에서 데이터는 숫자 뿐이지만 UI에서 문자열로 받게 된다. 그러므로 필드가 비어 있을 수 있고 잘 처리하는지 확인해야 한다.

마지막으로 배열을 받는 producers에 문자열을 넣으면 어떤 결과가 나오는지 실험한다. Mocha의 경우 실패로 처리한다. 어떤 프레임워크는 에러로 처리한다. 이 상황에 대응하는 방법은 경우에 따라 다르다. 이러한 테스트는 리팩터링 하기 전에는 작성하지 않는 것을 추천한다.