## 챕터 6 - 변경 가능한 데이터 구조를 가진 언어에서 불변성 유지하기

### 6-1. 모든 동작을 불변형으로 만들 수 있나요?

앞서 우리는 제품을 추가하는 기능에 불변성을 유지하여 작성했다. 다음으로 더 많은 동작에 불변성을 적용해본다.

장바구니에 대한 동작 중 불변성으로 구현하기 어려운 예시 중 하나로 “**제품 이름으로 제품 구매 수량 바꾸기”**를 제시한다. 이는 **중첩 데이터**를 다루기 때문에 불변하게 구현하기 어렵다고 주장한다.

`**중첩 데이터** - 데이터 구조 안에 데이터 구조가 있는 경우`

### 6-2. 동작을 읽기, 쓰기 또는 둘 다로 분류하기

동작(함수)는 읽기/쓰기/읽기와쓰기로 분류할 수 있다.

읽기는 정보를 가져오며 데이터를 바꾸지 않기 때문에 비교적 다루기 쉽다.

쓰기는 데이터를 바꾸고 바뀐 값에 의해 프로그램 전체에 영향을 줄 수 있기 때문에 제한적인 쓰기를 제공해야 한다. 쓰기를 제한적이게 하는 방법 중 하나가 불변성의 원칙을 따르는 것이다. 책에서 계속해서 사용하는 방식인 카피-온-라이트가 그 중 하나이다.

읽기와쓰기는 쓰면서 동시에 읽는 경우이다. 뒤에서 추가로 설명한다. (`shift()`를 예시로)

`**CQS(Command Query Separation)** - 하나의 함수는 하나의 동작을 하도록 설계한다.`

### 6-3. 카피-온-라이트 원칙 세 단계

카피-온-라이트로 만들기 위한 세 단계를 설명한다.

```tsx
function add_element_last(array, elem) {
  var new_array = arr.slice(); // 1. 복사본 만들기
  new_array.push(elem); // 2. 복사본 변경하기
  return new_array; // 3. 복사본 리턴하기
}
```

그리고 위 함수는 쓰기가 아닌 읽기라고 한다. → 이 부분은 약간 인지부조화가 온다..;

### 6-4. 카피-온-라이트로 쓰기를 읽기로 바꾸기 ~ p.121

이름을 찾아 해당 상품을 장바구니에서 제거하는 쓰기 동작을 읽기 동작으로 바꾸며 진행된다.

카피-온-라이트 단계를 따라 함수를 수정하고, 일반화 시키는 것까지 이른다. (중략..)

### 6-5. 읽기와쓰기 동작은 어떻게 해야 할까요?

읽기와쓰기를 하는 대표적인 함수인 `shift()`를 어떻게 카피-온-라이트를 적용시켜 읽기 동작으로 바꿀 수 있는지 설명한다.

1. 읽기와 쓰기 함수로 각각 분리한다. (CQS)
2. 함수에서 값을 두 개 리턴한다.

2가지 방법이 있으나 1번 방식이 좋은 방법이다.

1번 방식은 읽기 동작 함수와 쓰기 동작 함수를 만드는데, 쓰기 동작 함수에 카피-온-라이트를 적용해 읽기로 바꾼다.

`**장바구니 리스트 구조** - 배열 vs 맵`

### 6-6. 불변 데이터 구조는 충분히 빠릅니다.

일반적으로 불변 데이터가 가변 데이터보다 메모리를 더 많이 쓰고 느리다. (복사) 하지만 다음 이유로 인해 이는 걱정하지 않아도 된다고 설명한다.

- 언제든 최적화할 수 있다.
  - 개발을 하며 예상하기 힘든 병목 지점은 발생하기 마련이다.
  - 성능 개선을 예측하여 진행하는 오버 엔지니어링은 지양해야 한다.
  - 성능 개선은 문제를 발견했을 때 해야한다.
- 가비지 콜렉터는 빠르다.
  - 최신 언어는 굉장히 최적화된 가비지 콜렉터가 동작한다.
- 생각보다 많이 복사하지 않는다.
  - 지금까지 `slice()`를 통해 얕은 복사를 진행했기에 복사 연산을 많이하지 않았다.
  - 이것이 가능한 이유는 깊은 곳에 있는 속성에 직접 접근하지 않고 통으로 교체하는 동작만 있었기 때문에 가능한 것이다.
- 함수형  언어에는 구현체가 있다.

### 6-7. 객체 구조에서 카피-온-라이트

(중략..)