## 챕터 7 - HTTP/2의 신택스: 프로토콜 재정의

### 7.1 HTTP/2

HTTP/1.1은 컴퓨터 업계에서 이례적으로 오래 사용되었다. HTTP/2는 1.1이 나오고 16년만에 나왔다.

대규모 업데이트이고, 스트림, 우선 순위 설정, 서버 사이드 푸시, 헤더 압축 등이 추가되었다.

2로 넘어오면서 통신 포맷(?)은 똑같고 코드 레벨의 변경만 있다.

HTTP2의 목적은 통신 고속화이다.

이 외에도 TLS의 암호 스위트 제한이 있다.

1.0, 1.1을 걸쳐 TCP 레벨에서는 캐시, keep-alive, 압축, 청크, 파이프라이닝 등을 통해 성능 개선을 이뤄냈다.

2.0에서는 헤더부 압축이나 파이프라이닝 대체 구현을 추가한다.

상위 호환성 문제 → 파이프라이닝을 지원하는 서버인지 클라이언트가 확인을 선행하는 것

### 7.1.1 스트림을 이용한 통신 고속화

HTTP/2의 가장 큰 변화는 바이너리 기반 프로토콜로 변화했다는 점이다. 각 데이터는 프레임 단위로 송수신한다. 1.1에서는 1:1 = 요청 : TCP 소켓 이었기 때문에 2~6개 TCP 접속을 병렬화했다.

HTTP/2에서는 하나의 TCP에 스트림이라는 가상의 TCP 소켓을 만들어 통신한다. 이는 프레임에 따른 플래그로 간단히 만들고 닫을 수 있는 규칙으로 되어 있고, 일반 TCP처럼 핸드셰이크가 필요 없다. 따라서 ID값과 TCP 통신 용량이 허락하는 한, 몇 만번의 접속도 병렬화할 수 있다.

HTTP2 스트림과 TCP 접속 상태에는 스테이트 머신이 정의되어 있다. 스트림의 상태머신에서는 idle 상태에서 헤더를 받으면 즉시 통신 가능한 Open이 된다.

스트림 헤더를 보면 Stream Identifier라는 헤더가 있다. 스트림은 실체가 없는 논리적 구조이고, 같은 Stream Identifier를 가진 일련의 프레임은 수신 시 그룹화되고 같은 스트림에서 온 데이터로 취급된다.

Stream Identifier의 0은 예약되어 있고, 홀수는 클라이언트, 짝수는 서버에서 사용한다.

프레임은 위에서 언급했듯이 플래그를 따라 설정할 수 있다.

### 7.1.2 HTTP/2의 애플리케이션 계층

메서드, 경로, 스테이터스 코드 등이 모두 헤더로 들어가게 된다..!

1.1은 텍스트 프로토콜이었기에 헤더의 끝을 찾기 위해 순서를 고려하느라 고급 병렬 처리에 어려움이 있었다. 2에서는 프레임 크기부터 받고, 프레임 단위로 TCP 소켓에서 쉽게 분리하여 버퍼를 빠르게 비울 수 있게 됐다.

바디는 Content-Length를 통해 청크 형식일 때도 크기가 정해져 있어 로드 처리 비용이 다르지는 않지만, 요청이 여러개면 이야기가 달라진다. 1.1에서는 하나의 요청 중에 다른 요청 처리를 할 수 없었다. 6개의 병렬 통신 중이어도 하나에 묶여있으면 다른 통신을 할 수 없었다. 허나 2에서는 프레임 독립적이기에 가능하다.

### 7.1.3 플로 컨트롤

HTTP/2는 애플리케이션 계층이지만 트랜스포트 계층에 가까운 것을 내부에 가지고 있는 것이 특징이다. 플로우 컨트롤(흐름 제어)도 TCP 소켓과 거의 같은 기능을 구현했다. (~= OS 스레드와 그린 스레드)

플로우 컨트롤은 스트림을 효율적으로 흐르게 하기 위한 제어 처리이다. 통신 속도가 차이가 나는 기기의 조합으로 통신할 때 손실을 줄이는 것이 목적이다. 이를 위해 윈도우 크기 관리를 사용한다. 송신 측에서 상대의 최대 윈도우 크기로 보내고 수신 측에서 패키 처리 후 여유가 생기면 WINDOW_UPDATE 프레임을 이용해 반환하는 방식이다.

### 7.1.4 서버 푸시

서버 푸시는 1.1-2에서 확실히 다른 시맨틱스 중 하나이다. 서버 푸시라는 단어이지만 사실 클라이언트가 요청하기 전까지 받을 수 없다. 서버는 푸시할 컨텐츠를 사전에 캐시해놓고 요청이 오면 바로 응답한다.

### 7.1.5 HPACK을 이용한 헤더 압축

HPACK이라는 방식으로 헤더를 압축한다. 일반적인 압축 알고리즘과 달리 사전의 사전을 가진다(?)

같은 커넥션에 등장한 헤더는 인덱스화되어 동적 테이블에 저장된다.

### 7.1.6 SPDY와 QUIC

2의 역사를 말할 때 뺄수 없는 것이 구글이 개발한 SPDY이다. (근간)

구글은 서비스 내부에 신규 프로토콜을 검증할 수 있는 인프라가 있다. 그렇게 SPDY를 발전시켜 HTTP/2에 바톤을 넘겼다.

웹사이트 구성에 따라 30~300% 향상이 있었고, 작은 파일 전송이 많을수록 효과적이다.

1.1때는 가급적 적은 파일 수를 만들어내는 것이 일반적이었다. 2부터는 적은 파일량의 효과는 작아졌지만, 파일 크기가 작아지면 패킷 단편화(?) 케이스도 생긴다. 결합하면 통신량 줄지만, 자잘하면 캐시가 살아남을 확률 높아진다.. 케바케이다.

구글은 이에 더 빠르게 하기 위해 UDP 소켓에 QUIC이라는 프로토콜도 준비했다. 기존 UDP에 재전송 처리, 혼잡 제어 등을 자체 구현했다.

또, 핸드셰이크 과정을 통합해 더 적은 비용이 든다. 0~1RTT

TCP와 HTTP에서 중복 처리되던 부분도 공통 처리한다.

### 7.2 Fetch API

잘 아는 Fetch API는 다음과 같은 특징이 있다.

- XHR보다 오리진 서버 밖으로 액세스 등 CORS 제어가 쉬워진다.
- 자바스크립트의 모던한 비동기 처리 기법인 프로미스를 따른다.
- 캐시를 제어할 수 있다.
- 리다이렉트를 제어할 수 있다.
- 레퍼러 정책을 설정할 수 있다.
- Service Worker 내에서 이용할 수 있다.

Fetch가 저수준 API로 소개되지만 소켓 단위를 다룰 수 있는 것은 아니다. 캐시 등을 제어할 수 있지만 송수신 헤더 제한, CORS 정책은 벗어날 수 없다.

### 7.2.1 Fetch API의 기본

지원하는 데이터형(json,text,formData,blob,arrayBuffer), 메서드(GET,HEAD,POST 등), CORS모드, Credentials 등을 설정할 수 있다.

Fetch vs axios?

### 7.2.2 Fetch API만 할 수 있는 것

캐시 제어가 가능하다. no-store, no-cache, force-cache, only-if-cached 등을 통해 설정한다.

리다이렉트 제어가 가능하다. follow, manual, error가 있다.

Service Worker 대응이 가능하다. 현재 Service Worker에서 외부 서비스로 접속할 수 있는 유일한 사양이다.

### 7.3 server-sent events

server-sent events는 HTML5의 기능 중 하나이다. HTTP/1.1의 청크 형식을 바탕으로 삼았고, 서버에서 임의 시점에 클라이언트에 이벤트를 통지할 수 있는 기능이다.

서버에서 정보를 돌려 보내는 방법으로는 폴링, 롱폴링이 있다. 요즘에 별도의 방법이 없을 때 폴백으로 사용하는 것이다.

server-sent events는 롱폴링과 청크를 조합한다. HTTP위에 텍스트 프로토콜을 실었고 MIME 타입은 text/event-stream이다.

EventSource 클래스를 통해 액세스할 수 있다.

onmessage 이벤트와 커스텀 태그 이벤트가 있다.

클라이언트는 메시지 ID를 기록하고 재접속 시에는 마지막 ID를 Last-Event-ID로 전송하여 최종 수신을 파악한다.

### 7.4 웹소켓

웹소켓은 서버/클라이언트 사이에 오버헤드가 적은 양방향 통신을 실현한다.

### 7.4.1 웹소켓은 스테이트풀

HTTP 기반 프로토콜과 차이점으로 스테이트풀이라는 특성이 있다.

### 7.4.2 자바스크립트의 클라이언트 API

TCP 소켓에 가까운 형태로 제공된다. 다음과 같은 프로세스로 동작한다.

1. 서버가 ip, 포트로 시작한다.
2. 클라이언트가 서버에게 통신한다고 선언한다.
3. 서버가 요청을 받아들인다.
4. 서버에 소켓 클래스의 인스턴스가 넘어온다.
5. 서버가 받아 처리하면, 클라이언트의 소켓 인스턴스는 송수신 기능이 활성화된다.

### 7.4.3 접속

웹소켓은 HTTP로 시작하여 프로토콜 업그레이드를 사용한다.

### 7.4.4 Socket.IO

[Socket.IO](http://Socket.IO) 기반으로 사용하는 것이 일반적이다.

- 웹소켓을 사용할 수 없을 때 xhr 롱 폴링으로 에뮬레이션해준다.
- 웹소켓 단절 시 자동 재접속한다.
- 로비 기능