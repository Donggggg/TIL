## 2장 - 리팩터링 원칙

### 2-1. 리팩터링 정의

저자는 많은 개발 용어들이 두루뭉실한 의미로 통용되고 있다고 생각한다. 나도 이 의견에는 충분히 공감한다. 새로운 개념을 학습할 때 용어의 정의를 확립하는 것에 시간을 쏟았던 경험이 종종 있었기 때문이다. 그래서 리팩터링을 구체적으로 정의하기 위한 저자의 노력에 초점을 맞춰 책을 읽어나가면 좋을 것 같다고 생각한다. 

리팩터링을 결론지어 정의해보자면 **동작을 보존하는 작은 단계를 거치고 작은 단계들을 순차적으로 연결하여 큰 변화를 만들어내는 일**이라고 주장한다. 그리고 리팩터링의 상위 개념으로 재구성(restructuring)이라는 개념을 두었다. 재구성의 종류 중 하나를 리팩터링으로 분류하고 리팩터링만의 특징을 다음과 같이 추가적으로 제시한다.

- 단계적 변화
체계적인 작은 변화를 **단계적으로 거쳐야 한다.**
- 전후 동작 유지
성능은 변할 수 있지만 사용자 관점에서는 **달라지는 점이 없어야 한다.** (그것이 버그일지라도..)

### 2-2. 두 개의 모자

독자와 켄트 벡은 기능 추가와 리팩터링이라는 두 개의 모자를 바꿔쓰며 개발을 한다고 비유했다. 개발을 하며 기능 추가와 리팩터링 작업을 머릿 속에 의도적으로 인지할 수 있도록 제안한 개념인 것 같다.

### 2-3. 리팩터링하는 이유

우선 리팩터링은 모든 문제를 해결하는 만병통치약이기 보다는 **건강한 상태로 유지시켜주는 영양제|약**이라고 생각한다. 리팩터링이 영양제라고 주장하는 이유는 다음과 같이 제시한다.

- **소프트웨어를 이해하기 쉬워진다.**
프로그래밍은 컴퓨터와 대화하는 것과 유사하다. 이는 내가 원하는 바를 정확히 표현하는 것이다. 이 표현을 컴퓨터만 보는 것이 아니라 사람(스스로)도 보게 된다. 그러므로 기능 개발에 몰두하기 보다는 리팩터링을 곁들여 나의 의도를 정확히 표현하는 것도 중요하다.
- **버그를 찾기 쉬워진다.**
코드를 이해하기 쉽다는 것은 버그를 찾기 쉽다는 말이기도 하다. 리팩터링을 하면 코드가 하는 일을 깊이 파악하게 되며 버그를 지나치려야 지나칠 수 없을 정도가 된다.
- **프로그래밍 속도를 높일 수 있다.**
결국 리팩터링은 프로그래밍 속도를 높이게 된다. 오히려 속도가 늦게 된다고 생각할 수 있으나, 저자의 경험으로 미루어보아 초기 진척 속도는 빠른 오래된 프로젝트가 새로운 기능을 추가하는데 오랜 시간이 걸리는 케이스가 많은 것 같다. 또, 기능 추가에 따른 버그가 발생하고 버그를 해결하는 시간도 꽤나 걸리게 된다. 그렇게 좋지 않은 설계의 코드 베이스가 쌓이며 차라리 새로 만들겠다! 라는 생각이 들정도가 된다. 그러므로 리팩터링을 통해 코드의 지구력(저자의 가설)을 높이면 빠르게 개발할 수 있는 상태를 오래 지속할 수 있다.

이 단락에서 저자는 계속해서 **본인의 평범함(?)을 강조**했다. 자신은 게으르고, 뛰어나지 않다는 말을 반복한다. 나도 스스로  굉장히 평범한 사람이라고 생각한다. 그래서인지 저자의 주장에 더욱 공감이 갔다. 
20년 전에는 개발에 들어가기 전에 완벽한 설계부터 해내야 한다는 것이 정설이었지만, 리팩터링은 완벽한 설계에 대한 압박감과 부담감을 덜어내준다고 말한다. 나도 이 전에 ‘설계’를 연습하며 완벽한 설계를 해내어 수정하고 싶지 않았지만 한계를 느끼고 스트레스를 받았던 경험이 있다. 조금 부족한 설계를 들고 개발을 하며 재구성을 했고 완벽하진 않지만 괜찮은 설계를 레이백으로 해낼 수 있었다. 
이렇듯 나도 엄청난 개발자는 아니기에 좋은 습관을 가진 괜찮은 개발자가 되면 좋을 것 같다는 생각을 할 수 있었고, 성장 방향성에 대해 고민할 수 있었다.

### 2-4. 언제 리팩터링해야 할까?

저자는 리팩터링을 한 시간 간격으로 진행한다고 한다. 그러다가 리팩터링을 해야할 때의 기준을 추천받게 되었다고 한다. 일명 3의 법칙이다. 간단하게 설명하자면 비슷한 일이 3번 반복되면 리팩터링한다. 

다음으로 리팩터링을 하는 여러 가지 상황을 제시한다.

1. 기능을 추가할 때
2. 코드를 처음 읽을 때(이해할 때) → 나아가 쓰레기 줍기(이해를 하며 비효율적인 코드를 발견했을 때)
3. 계획한 리팩터링보다 수시로 진행한다.
4. 코드를 리뷰할 때

### 2-5. 리팩터링 시 고려할 문제

리팩터링을 왜 해야하는지 그리고 언제 해야하는지에 대해서는 충분히 설명이 된 듯하다. 이제 리팩터링을 진행하며 발생할 수 있는 문제에 대해 이야기한다. 

- 새 기능 개발 속도 저하
리팩터링은 경제적인 이유로 하는 것이고, 진행함으로써 기능 추가의 비용이 줄어드는 것은 확실하다. 허나 기능 추가와 리팩터링에 대한 우선순위를 잘 고려해야 한다.(알잘딱깔센) 이를 잘 할 수 있는 방법은 경험치를 쌓는 것이다..
- 코드 소유권
팀이나 회사 단위에서 프로젝트의 코드 소유권 영역에 따른 제약을 설명한다. 저자는 공동 코드 소유권을 가지고 오픈소스 형식으로 개발을 진행해보라는 이야기도 한다. 팀 단위의 소유권은 공감이 되나 회사 단위는 나쁘지는 않지만.. 조금은 비효율적일 것이라는 생각이 든다.
- 브랜치
기능별 브랜치를 따는 전략은 마스터에 통합하는 주기가 굉장히 길어서 통합 과정에 비용이 꽤나 든다. 그러므로 CI를 도입하여 2~3일의 통합 주기를 가지는 것을 추천한다. 이 방식은 리팩터링과도 잘 어울린다. 이 두 방식을 합쳐 [익스트림 프로그래밍(XP)](https://ko.wikipedia.org/wiki/%EC%9D%B5%EC%8A%A4%ED%8A%B8%EB%A6%BC_%ED%94%84%EB%A1%9C%EA%B7%B8%EB%9E%98%EB%B0%8D)이 탄생한 것이다.
- 테스팅
리팩터링을 진행하며 발생할 수 있는 에러를 빠르게 발견하기 위해서 테스트 작성을 추천한다. 테스트를 작성함으로써 리팩터링에 대한 불안감을 해소하고 나아가 CI/CD 프로세스를 구축하는데 유리하게 된다. 테스트를 작성하기 어려운 상황이라면 자동 리팩터링 도구를 사용해 한정된 기능만 사용하는 것도 하나의 방법이다.
- 레거시 코드
거대한 레거시 코드라는 원석을 보석처럼 만들기 위한 과정을 설명한다. 여기서도 역시 테스트의 중요성을 강조하는데.. 거대한 레거시에 테스트가 전혀 작성되어 있지 않다면.. 저자가 제안한 방법보다 그냥 새로 만들고 싶을 것 같다. 굉장히..!
- 데이터베이스
과거에는 데이터베이스 리팩터링은 어려운 영역이었으나, 버저닝을 통해 난이도를 감소시킨 영역이 되었다.

### 2-6. 리팩터링, 아키텍처, 애그니(YAGNI)

위에서 언급했듯이 과거에는 완벽에 가까운 설계가 선행되어야 하기 때문에 골머리를 앓았었다. 이 문제점을 조금이나마 해결하기 위해 **유연성 메커니즘**을 도입한다. 유연성 메커니즘의 예시 중 하나로 함수의 매개변수를 통해 범용적으로 사용할 수 있게 구현하는 것이 있다. 하지만 유연성 메커니즘은 여러 이유(요구 사항 변경, 설계 실수 등)로 오히려 복잡성을 높이는 경우가 발생하기도 한다.

리팩터링을 활용한다면 다른 접근이 가능하다. **미래를 예측하지 않고, 현재까지 파악한 요구사항을 우아하게 해결하도록 설계한다.** 진행하며 요구사항을 더 잘 이해하게 되면 아키텍처도 리팩터링한다. 이러한 방식을 `YAGNI(You Aren’t Going to Need It)`이라고 한다.

### 2-7. 그 외

저자 개인의 경험담과 리팩터링 1판의 성공 신화 정도로 요약 가능하다.
