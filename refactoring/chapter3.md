## 챕터 3 - 코드에서 나는  악취

앞선 챕터에서 우리는 언제 왜 리팩터링을 해야 하는지에 대한 이야기를 나눴다. 이번 장에서는 리팩터링을 언제 해야 하는지에 대한 **시점**에 대한 이야기를 나눈다. 저자도 말하듯이 리팩터링의 시점은 **적립된 규칙이 없다.** 이를 구체적으로 정하기 위해 해결할 수 있는 문제의 징후인 `코드 스멜`이라는 개념을 제시한다. 추가적으로 숙련된 사람의 직관만큼 정확한 기준은 없음을 주장하며 다양한 코드 스멜의 종류를 서술한다.

### 3-1. 기이한 이름 (Mysterius Name)

- **혼란스러운 이름으로 작성된 경우**이다.
- 명확한 이름은 무슨 일을 하고 어떻게 사용해야 하는지 자연스레 알 수 있다.
- 해결법은 함수 선언 바꾸기, 변수 이름 바꾸기, 필드 이름 바꾸기가 있다.

### 3-2. 중복 코드 (Duplicated Code)

- **똑같은 코드 구조가 여러 곳에 반복되는 경우**이다.
- 코드가 중복되면 수정이 발생할 때마다 중복되는 모든 코드를 변경해야 한다.
- 해결법은 함수 추출하기, 메서드 올리기가 있다.

### 3-3. 긴 함수 (Long Function)

- **복잡하고 의도가 명확하지 않게 함수가 작성되는 경우**이다.
- 함수를 추출할 때 행위보다는 **의도**에 집중하여 작성한다.
- 해결법은 함수 추출하기, 조건문 분해하기, 조건부 로직을 다형성으로 바꾸기, 반복문 쪼개기가 있다.

### 3-4. 긴 매개변수 목록 (Long Parameter List)

- **함수가 너무 많은 매개변수를 가지는 경우**이다.
- 매개변수 목록이 길어지면 이해하기 어렵다.
- 해결법은 매개변수를 질의 함수로 바꾸기, 객체 통째로 넘기기, 매개변수 객체 만들기, 플래그 인수 제거하기, 여러 함수를 클래스로 묶기가 있다.

### 3-5. 전역 데이터 (Global Data)

- **전역 데이터가 사용되는 경우**이다.
- 전역 데이터는 어디서든 접근이 가능하기에 디버깅을 어렵게 만든다.
- 해결법은 변수 캡슐화하기가 있다.

### 3-6. 가변 데이터 (Mutable Data)

- **가변 데이터가 사용되는 경우**이다.
- 불변성이라는 개념이 있는 만큼 가변 데이터는 예측이 힘든 동작을 발생시킨다.
- 해결법은 변수 캡슐화하기, 변수 쪼개기, 질의 함수와 변경 함수 분리하기, 세터 제거하기, 여러 함수를 *로 묶기, 참조를 값으로 바꾸기(불변성)가 있다.

### 3-7. 뒤엉킨 변경 (Divergent Change)

- **하나의 모듈이 서로 다른 이유로 인해 변경되는 일이 많은 경우**이다.
- 단일 책임 원칙이 지켜지지 않은 경우이기도 하다.
- 서로 다른 맥락의 코드는 다른 모듈로 작성하는 것이 좋다.
- 해결법은 단계 쪼개기, 함수 옮기기가 있다.

### 3-8. 산탄총 수술 (Shotgun Surgery)

- **하나의 이유로 여러 모듈이 변경되는 일이 많은 경우**이다.
- 같은 맥락의 코드는 같은 모듈로 작성하는 것이 좋다.
- 해결법은 함수 및 필드 옮기기, 여러 함수를 *로 묶기가 있다.

### 3-9. 기능 편애 (Feature Envy)

- **모듈 내부 상호작용보다 모듈 간 상호작용이 많은 경우**이다.
- 해결법은 함수 옮기기, 함수 추출하기가 있다.
- [전략 패턴](https://victorydntmd.tistory.com/292)과 [방문자 패턴](https://velog.io/@newtownboy/%EB%94%94%EC%9E%90%EC%9D%B8%ED%8C%A8%ED%84%B4-%EB%B0%A9%EB%AC%B8%EC%9E%90%ED%8C%A8%ED%84%B4Visitor-Pattern)은 기능 편애를 일으키지만 뒤엉킨 변경을 제거하는 대표적인 패턴이다.

### 3-10. 데이터 뭉치 (Data Clumps)

- **묶일 수 있는 데이터가 분리되어 작성되는 경우**이다.
- 해결법은 클래스 추출하기, 매개변수 객체 만들기, 객체 통째로 넘기기가 있다.

### 3-11. 기본형집착 (Primitive Obesession)

- **기본형 변수에 집착하는 경우**이다.
- 해결법은 기본형을 객체로 바꾸기, 타입 코드를 서브클래스로 바꾸기, 조건부 로직을 다형성으로 바꾸기가 있다.

### 3-12. 반복되는 switch문 (Repeated Switches)

- **switch문의 로직 반복되는 경우**이다.
- 해결법은 조건부 로직을 다형성으로 바꾸기가 있다.

### 3-13. 반복문 (Loop)

- **반복문이 있는 경우**이다…?
- 해결법은 반복문을 파이프라인으로 바꾸기이다.

### 3-14. 성의 없는 요소 (Lazy Element)

- **빈약한 요소가 있는 경우**이다.
- 예시로 메서드가 하나 뿐인 클래스, 리팩터링을 거친 후 역할이 줄어든 클래스가 있다.
- 해결법은 함수 인라인하기, 클래스 인라인하기, 계층 합치기가 있다.

### 3-15. 추측성 일반화 (Speculative Generality)

- **추측성으로 작성한 코드가 있는 경우**이다.
- 예시로 하는 일이 없는 추상 클래스, 사용되지 않는 매개변수가 있다.
- 해결법은 계층합치기, 함수 선언 바꾸기가 있다.

### 3-16. 임시 필드 (Temporary Field)

- **특정 상황에서만 값이 설정되는 필드가 있는 경우**이다.
- 코드를 이해하기 어렵게 만들기에 제거해야 한다.
- 해결법은 클래스 추출하기, 특이 케이스 추가하기가 있다.

### 3-17. 메시지 체인 (Message Chain)

- **요청이 객체를 체이닝하여 이뤄지는 경우**이다.
- 해결법은 위임 숨기기가 있다.

### 3-18. 중개자 (Middle Man)

- **중개를 지나치게 하는 경우**이다…?
- 해결법은 중개자 제거하기가 있다.

### 3-19. 내부자 거래 (Insider Trading)

- **결합도가 높은 경우**이다.
- 해결법은 함수 옮기기, 필드 옮기기, 위임 숨기기가 있다.

### 3-20. 거대한 클래스 (Large Class)

- **너무 많은 일을 하는 클래스가 있는 경우**이다.
- 해결법은 클래스 추출하기, 슈퍼클래스 추출하기가 있다.

### 3-21. 서로 다른 인터페이스의 대안 클래스들 (Alternative Classes with Different Interfaces)

- **인터페이스가 일치하지 않은 대체 가능한 클래스가 있는 경우**이다.
- 해결법은 함수 선언 바꾸기 → 함수 옮기기 → 슈퍼 클래스 추출하기이다.

### 3-22. 데이터 클래스 (Data Class)

- **데이터 클래스를 다른 클래스에서 깊이 다루는 경우**이다. (Ex. 화폐, 전화번호 등)
- 해결법은 레코드 캡슐화하기, 세터 제거하기, 함수 옮기기, 함수 추출하기가 있다.

### 3-23. 상속 포기 (Refused Bequest)

- **서브클래스가 필요없는 것까지 상속받는 경우**이다.
- 해결법은 메서드/필드 내리기로 공통 부분만 부모에 남기기, 서브/슈퍼 클래스를 위임으로 바꾸기가 있다.

### 3-24. 주석 (Comments)

- **불필요한 주석이 있는 경우**이다.
- 해결법은 함수 추출하기, 함수 선언 바꾸기, 어서션 추가하기가 있다.

앞서 제안한 모든 코드 스멜과 그 해결법은 연쇄적인 리팩터링을 발생시킨다. 양이 좀 있고 예시가 없는 객체 지향 위주의 설명이었기에 100% 와닿지는 못했지만 해당 내용을 인지하고 개발한다면 보이는 것이 분명 있을 것이라고 생각한다.